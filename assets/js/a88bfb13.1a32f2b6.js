"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8698],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>m,mdx:()=>g,useMDXComponents:()=>p,withMDXComponents:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=a.createContext({}),u=function(e){return function(t){var n=p(t.components);return a.createElement(e,i({},t,{components:n}))}},p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,c=u["".concat(r,".").concat(m)]||u[m]||h[m]||i;return n?a.createElement(c,l(l({ref:t},d),{},{components:n})):a.createElement(c,l({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},36509:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(87462),o=(n(67294),n(3905));const i={},r="Configurations",l={unversionedId:"rule_authors/configurations",id:"rule_authors/configurations",title:"Configurations",description:"This doc focuses mostly on how configurations and related features are implemented. For",source:"@site/../docs/rule_authors/configurations.md",sourceDirName:"rule_authors",slug:"/rule_authors/configurations",permalink:"/docs/rule_authors/configurations",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"manualSidebar",previous:{title:"Transitive Sets",permalink:"/docs/rule_authors/transitive_sets"},next:{title:"Configuration Transitions",permalink:"/docs/rule_authors/configuration_transitions"}},s={},d=[{value:"Context",id:"context",level:2},{value:"<code>platform()</code>, <code>constraint_setting()</code>, <code>config_setting()</code>, etc",id:"platform-constraint_setting-config_setting-etc",level:3},{value:"Selectable attributes",id:"selectable-attributes",level:2},{value:"Selectable resolution",id:"selectable-resolution",level:2},{value:"Target Platform Resolution",id:"target-platform-resolution",level:2},{value:"Configuration propagation",id:"configuration-propagation",level:2},{value:"Transitions",id:"transitions",level:2},{value:"ConfigurationInfo, <code>platform()</code> analysis, and more",id:"configurationinfo-platform-analysis-and-more",level:2},{value:"Configurations and output paths",id:"configurations-and-output-paths",level:2},{value:"Target platform compatibility",id:"target-platform-compatibility",level:2},{value:"Buck v1 compatibility",id:"buck-v1-compatibility",level:3},{value:"Incompatible target skipping",id:"incompatible-target-skipping",level:2},{value:"Execution platforms",id:"execution-platforms",level:2},{value:"Execution deps",id:"execution-deps",level:2},{value:"Toolchain deps",id:"toolchain-deps",level:2},{value:"Running non-execution deps",id:"running-non-execution-deps",level:2},{value:"Execution platform resolution",id:"execution-platform-resolution",level:2},{value:"Execution groups",id:"execution-groups",level:2},{value:"Execution platform inheritance",id:"execution-platform-inheritance",level:2}],u={toc:d};function p(e){let{components:t,...n}=e;return(0,o.mdx)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"configurations"},"Configurations"),(0,o.mdx)("p",null,"This doc focuses mostly on how configurations and related features are implemented. For\nthe user docs (which are also quite helpful for understanding this), see ????? (for now\ntry the ",(0,o.mdx)("a",{parentName:"p",href:"https://buck.build/"},"buck1 docs")," or the ",(0,o.mdx)("a",{parentName:"p",href:"https://docs.bazel.build/versions/master/skylark/config.html"},"bazel docs")," for similar features that buck2 has been\nmodeled after)."),(0,o.mdx)("p",null,"TODO(cjhopman): Configurations needs some user docs. Could probably skip some of the below context if we had them."),(0,o.mdx)("h2",{id:"context"},"Context"),(0,o.mdx)("p",null,'Buck "Configurations" provides an API to express the different ways projects and targets can be built.'),(0,o.mdx)("p",null,"A configuration consists of a set of constraints and config settings (i.e. values from buckconfig). These are determined by a base platform\nthat sets the initial values and then a series of transitions that may change them."),(0,o.mdx)("p",null,"The common way that users are exposed to configurations is in ",(0,o.mdx)("inlineCode",{parentName:"p"},"select()")," invocations where the resolution is based on the\nconfiguration."),(0,o.mdx)("p",null,"A build may involve many configurations and even a particular target label (",(0,o.mdx)("inlineCode",{parentName:"p"},"//:foo"),") may end up with multiple\ninstance in the configured graph with different configurations."),(0,o.mdx)("h3",{id:"platform-constraint_setting-config_setting-etc"},(0,o.mdx)("inlineCode",{parentName:"h3"},"platform()"),", ",(0,o.mdx)("inlineCode",{parentName:"h3"},"constraint_setting()"),", ",(0,o.mdx)("inlineCode",{parentName:"h3"},"config_setting()"),", etc"),(0,o.mdx)("p",null,"TODO(cjhopman): Describe this enough for context needed below"),(0,o.mdx)("h2",{id:"selectable-attributes"},"Selectable attributes"),(0,o.mdx)("p",null,"Almost all rule attributes can be set to a ",(0,o.mdx)("inlineCode",{parentName:"p"},"select()"),' value, such an attribute is "selectable". These attributes final resolved value will depend on the configuration.'),(0,o.mdx)("p",null,"There are some attributes that cannot use a ",(0,o.mdx)("inlineCode",{parentName:"p"},"select()"),', such attributes are "not selectable". Examples include attributes that buck needs to\nread from the unconfigured node (ex. "name", "default_target_platform") and attributes that are used by ',(0,o.mdx)("inlineCode",{parentName:"p"},"platform()")," rules and their\ndependencies (see below)."),(0,o.mdx)("p",null,"TODO(cjhopman): Should rule authors be able to set attrs as not selectable?"),(0,o.mdx)("h2",{id:"selectable-resolution"},"Selectable resolution"),(0,o.mdx)("p",null,'Resolving selectable attributes is pretty straightforward, it happens when constructing the "configured target node". At that point, we have the full configuration\navailable and se we can lookup whether each constraint in the select is satisfied or not.'),(0,o.mdx)("p",null,"TODO(cjhopman): Describe how checking refinement is implemented."),(0,o.mdx)("h2",{id:"target-platform-resolution"},"Target Platform Resolution"),(0,o.mdx)("p",null,"When targets are provided on the command line (e.g. ",(0,o.mdx)("inlineCode",{parentName:"p"},"buck build //:foo"),') or otherwise where there\'s no indication of what configuration\nthat target will be built in, configurations are determined by performing "target platform resolution" on\nthe unconfigured target labels.'),(0,o.mdx)("p",null,"Target Platform Resolution for a target ",(0,o.mdx)("inlineCode",{parentName:"p"},"foo")," works by:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},'lookup (unconfigured) target node for "foo"'),(0,o.mdx)("li",{parentName:"ol"},'if there\'s a "default_target_platform" attribute, use that'),(0,o.mdx)("li",{parentName:"ol"},"else, use the cell's default platform")),(0,o.mdx)("p",null,"This is performed indepedently for any targets that need a platform. Since this resolution is done without\na configuration, it means that the default_target_platform attribute ",(0,o.mdx)("strong",{parentName:"p"},"is not selectable"),"."),(0,o.mdx)("p",null,"This target platform will form the initial configuration for the node."),(0,o.mdx)("p",null,"TODO(cjhopman): how does a user explicitly specify on the command line a target platform such that the target does not\ngo through target platform resolution? Are there other cli options/flags/etc that affect target platform resolution?"),(0,o.mdx)("h2",{id:"configuration-propagation"},"Configuration propagation"),(0,o.mdx)("p",null,"Once we've configured the top-level nodes via target platform resolution, the configuration is propagated to dependencies (possibly altered by transitions)."),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"We do not apply target platform resolution to all nodes in the graph.")),(0,o.mdx)("h2",{id:"transitions"},"Transitions"),(0,o.mdx)("p",null,'A "transition" transforms a configuration by adding or changing constraint values and config settings or by setting an entirely new underlying target platform.'),(0,o.mdx)("p",null,"More details in: ",(0,o.mdx)("a",{parentName:"p",href:"/docs/rule_authors/configuration_transitions"},"Configuration transitions"),"."),(0,o.mdx)("h2",{id:"configurationinfo-platform-analysis-and-more"},"ConfigurationInfo, ",(0,o.mdx)("inlineCode",{parentName:"h2"},"platform()")," analysis, and more"),(0,o.mdx)("p",null,'The definition of a platform (either execution or target) is done with a "platform" rule instance. The configuration is actually\npart of the analysis result of the platform target (the ConfigurationInfo provider instance). This is convenient from\nan implementation standpoint, but it leads to a situation where some nodes are analyzed with an "unbound" Configuration. All the\nrule types involved in defining a platform may be analyzed with an unbound configuration (',(0,o.mdx)("inlineCode",{parentName:"p"},"platform()"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"config_setting()"),",\n",(0,o.mdx)("inlineCode",{parentName:"p"},"constraint_setting()"),', etc). These are sometimes called "configuration rules". This also means that all the attributes of these rules are not selectable.'),(0,o.mdx)("p",null,'Configurations also reference a few other provider instances like ConstraintSettingInfo. All of these end up being potentially\nproduced in a context with an "unbound" configuration.'),(0,o.mdx)("p",null,'Using analysis for this also means that "configuration" and "analysis" are not distinct phases within a build (though are\nstill distinct for a node and are still conceptually useful).'),(0,o.mdx)("h2",{id:"configurations-and-output-paths"},"Configurations and output paths"),(0,o.mdx)("p",null,'Because a target may appear within a build in multiple different configurations we cannot derive output paths based on\njust targets (as then we\'d have multiple actions map to the same outputs). For this reason, we encode the target and the configuration\ninto output paths. The configuration is currently represented as a hash of its values (i.e. "hashed buck-out").'),(0,o.mdx)("h2",{id:"target-platform-compatibility"},"Target platform compatibility"),(0,o.mdx)("p",null,"All (non-configuration) rules support a ",(0,o.mdx)("inlineCode",{parentName:"p"},"target_compatible_with")," attribute. In addition, the rule itself can define\n",(0,o.mdx)("inlineCode",{parentName:"p"},"target_compatible_with")," constraints that affect all instances. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"target_compatible_with")," attribute is a list of\nconstraints/config settings and it ",(0,o.mdx)("strong",{parentName:"p"},"is selectable"),"."),(0,o.mdx)("p",null,"Target platform compatibility is transitive, all ",(0,o.mdx)("em",{parentName:"p"},"dependents")," of an incompatible target are incompatible. In other words,\na node is compatible if and only if the node itself and all of its transitive dependencies are compatible."),(0,o.mdx)("p",null,'In buck, this is implemented by target analysis returning either the normal analysis result or an indicator\nthat the node is incompatible with the target platform. It is not part of the "configured target node" because\nthe "configured target node" does not depend on information from dependencies.'),(0,o.mdx)("p",null,"TODO(cjhopman): Something about debuggability of incompatibility, especially due to needing it to figure out transitive incompatibility."),(0,o.mdx)("h3",{id:"buck-v1-compatibility"},"Buck v1 compatibility"),(0,o.mdx)("p",null,"Buck2 also supports the Buck v1 legacy ",(0,o.mdx)("inlineCode",{parentName:"p"},"compatible_with")," field on nodes but it has different behavior. In summary:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"compatible_with"),": List of constraints, ",(0,o.mdx)("em",{parentName:"li"},"any")," of them must match the configuration to be compatible."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"target_compatible_with"),": List of constraints, ",(0,o.mdx)("em",{parentName:"li"},"all")," of them must match the configuration to be compatible.")),(0,o.mdx)("h2",{id:"incompatible-target-skipping"},"Incompatible target skipping"),(0,o.mdx)("p",null,"In a build-like command where a non-literal target pattern is provided (ex. ",(0,o.mdx)("inlineCode",{parentName:"p"},"buck build //:")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"buck build //foo/..."),') the target pattern\nwill be resolved to a set of unconfigured targets. Those targets will then go through "target platform resolution". If any of those targets\nresolve to a platform where they are incompatible, building them will be skipped. Users generally expect and prefer this behavior to\nneeding to explicit specify only the targets that can build in their current context.'),(0,o.mdx)("p",null,"If an explicitly specified literal is incompatible, it is an error."),(0,o.mdx)("p",null,"The implementation checks compatibility when looking up the analysis results for configured nodes requested (in the non-ignored flow, it uses\nthat analysis result to lookup the default outputs and build them)."),(0,o.mdx)("h2",{id:"execution-platforms"},"Execution platforms"),(0,o.mdx)("p",null,'Execution platforms/configurations are used to represent the platforms where build execution happens. These are defined similar to target platforms.\nThese may or may not be what one would logically consider different "platforms", for example, there could be multiple different execution platforms\nthat all execute things similarly on the local machine.'),(0,o.mdx)("p",null,"A build configures a fixed list of one or more execution platforms."),(0,o.mdx)("h2",{id:"execution-deps"},"Execution deps"),(0,o.mdx)("p",null,'Some target deps are "execution deps". These are the dependencies of the target that should be built for the execution platform. For example,\na compiler or other build tool would be an execution dep. This includes all exe macro deps (ex. ',(0,o.mdx)("inlineCode",{parentName:"p"},"$(exe //:tool)"),") and includes all ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.exec_dep()")," deps."),(0,o.mdx)("h2",{id:"toolchain-deps"},"Toolchain deps"),(0,o.mdx)("p",null,"In addition to ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.exec_dep()"),", we have an ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.toolchain_dep()")," primitive that's similar but different in an important way. These nodes don't select\ntheir execution platform, but instead have it forced on them by whatever includes them, hence it must be recorded in the configured target label.\nThe execution platform resolution sees through them."),(0,o.mdx)("p",null,"In other words, ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.toolchain_dep()")," is like a mix of ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.dep()")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.exec_dep()"),": it inherits target platform like ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.dep()")," (so any\n",(0,o.mdx)("inlineCode",{parentName:"p"},"select()"),"s on the target of the ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.toolchain_dep()")," will evaluate as if they were on the target containing the ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.toolchain_dep()")," - i.e., target\nplatform gets inherited as normal) and any ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.exec_dep()"),"s of the ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.toolchain_dep()")," target become ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.exec_deps()")," on the dependent of\ntarget the ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.toolchain_dep()")," (i.e., they get passed up the dep tree, so participate in exec platfom resolution)."),(0,o.mdx)("p",null,"Illustrated as an example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},'target(\n    name = "A",\n    toolchain = attrs.toolchain_dep(default = ":B"),\n)\ntarget(\n    name = "B",\n    tool = attrs.exec_dep(default = ":C")\n)\n')),(0,o.mdx)("p",null,"The above means that ",(0,o.mdx)("inlineCode",{parentName:"p"},":C")," will be an execution dependency of ",(0,o.mdx)("inlineCode",{parentName:"p"},":A")," and any ",(0,o.mdx)("inlineCode",{parentName:"p"},"select()"),"s defined in ",(0,o.mdx)("inlineCode",{parentName:"p"},":B")," would be evaluated against\nthe same target platform as ",(0,o.mdx)("inlineCode",{parentName:"p"},":A")," (as target platform gets inherited by ",(0,o.mdx)("inlineCode",{parentName:"p"},"attrs.toolchain_dep()"),"s)."),(0,o.mdx)("h2",{id:"running-non-execution-deps"},"Running non-execution deps"),(0,o.mdx)("p",null,"If you have a binary that you want to run, but it isn't a build tool, then you should use ",(0,o.mdx)("inlineCode",{parentName:"p"},"$(exe_target //:binary)")," rather than ",(0,o.mdx)("inlineCode",{parentName:"p"},"$(exe //:binary)"),". That\nwill run the same binary that you'd get from ",(0,o.mdx)("inlineCode",{parentName:"p"},"buck2 build"),", rather than one that is built for the execution platform."),(0,o.mdx)("h2",{id:"execution-platform-resolution"},"Execution platform resolution"),(0,o.mdx)("p",null,"During analysis, unlike target platform resolution, every configured node undergoes execution platform resolution independently (see exception below). This\nmeans that even for a specific target platform, different nodes in the graph can be built on different execution platforms."),(0,o.mdx)("p",null,"This works roughly like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"next: for platform in execution_platforms:\n    if exec_compatible_with(target, platform):\n        for dep in target.execution_deps():\n            if !target_compatible_with(dep, platform):\n              continue next\n        return platform\nreturn err\n")),(0,o.mdx)("p",null,"One important note here is that until the execution platform has been resolved, ",(0,o.mdx)("strong",{parentName:"p"},"we do not know the configuration for execution deps"),". Only after\nwe've resolved the execution platform can we configure the execution deps (and can also only perform analysis for them at that point)."),(0,o.mdx)("p",null,"For the normal case, a particular configured target node performs execution platform resolution a single time. The execution platform\n",(0,o.mdx)("strong",{parentName:"p"},"is not")," encoded in output paths."),(0,o.mdx)("p",null,"Regarding target compatibility, you can imagine the following pseudo-code for the ",(0,o.mdx)("inlineCode",{parentName:"p"},"target_compatible_with()")," function above:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-python"},"def target_compatible_with(target, cfg):\n    for constraint in target.target_compatible_with:\n        if not satisfied(constraint, cfg):\n            return False\n\n    if len(target.compatible_with) > 0:\n        found_satisfied_constraint = False\n        for constraint in target.compatible_with:\n            if satisfied(constraint, cfg):\n                found_satisfied_constraint = True\n                break\n        if not found_satisfied_constraint:\n            return False\n\n    for (dep, dep_cfg) in direct_deps(target):\n        # NB: recursive call\n        if not target_compatible_with(dep, dep_cfg):\n            return False\n\n    return True\n")),(0,o.mdx)("p",null,"TODO(cjhopman): What are the requirements on rule authors? Especially, do they need to ensure that all possible execution platforms will produce the same results?"),(0,o.mdx)("h2",{id:"execution-groups"},"Execution groups"),(0,o.mdx)("p",null,"Execution groups allow a rule to do execution platform resolution multiple times and then specify which of the resolved platforms each\naction runs in."),(0,o.mdx)("p",null,"TODO(cjhopman): Finish this documentation as we figure it out."),(0,o.mdx)("h2",{id:"execution-platform-inheritance"},"Execution platform inheritance"),(0,o.mdx)("p",null,"There are some (rare) cases where both a target and its dependency need to resolve to the same execution platform."),(0,o.mdx)("p",null,"An example of this would be a c++ toolchain that includes both target (ex. the stdlib) and\nexecution (ex. the compiler) components. In that case, we need the toolchain's execution deps to affect its users\nexecution platform resolution."),(0,o.mdx)("p",null,"To support this, there are mechanisms to indicate which dependencies need to inherit the execution platform resolution."),(0,o.mdx)("p",null,"Currently, since this could mean that a configured node appears in the build under multiple different execution platforms and since execution\nplatforms are not included as part of output paths, users must use this feature carefully."),(0,o.mdx)("p",null,'TODO(cjhopman): figure out what restrictions this needs to apply so that users don\'t need to be the ones responsible for correctness\nTODO(cjhopman): figure out/document those "mechanisms"'))}p.isMDXComponent=!0}}]);